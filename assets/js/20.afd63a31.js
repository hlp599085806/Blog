(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{583:function(t,e,r){"use strict";r.r(e);var a=r(17),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"react-fiber"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[t._v("#")]),t._v(" React Fiber")]),t._v(" "),r("h4",{attrs:{id:"_1-什么fiber-fiber架构解决了什么问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么fiber-fiber架构解决了什么问题"}},[t._v("#")]),t._v(" 1. 什么fiber?  fiber架构解决了什么问题")]),t._v(" "),r("p",[t._v("​\tfiber是React中最小的执行单元，在遍历更新的时候都不是使用的真实DOM，而是采用的虚拟DOM，fiber可以理解为React的虚拟DOM。")]),t._v(" "),r("p",[t._v("​\tfiber结构的出现是 "),r("span",{staticStyle:{color:"red"}},[r("code",[t._v("Reactv16")])]),t._v("版本，其目的是为了解决大型React应用卡顿问题。")]),t._v(" "),r("p",[t._v("​\t为什么它能解决卡顿呢？"),r("span",{staticStyle:{color:"red"}},[r("code",[t._v("Reactv15")])]),t._v("及以前的版本，React对于虚拟DOM是采用递归的方式来进行，例如一次更新则会从应用的根部开始递归更新，递归一旦开始，中途无法中断，大型React项目层级都是随着维护越来越深，导致需要更新的时间也会越来越长。")]),t._v(" "),r("p",[t._v("​\t它是如何解决卡顿的呢：引入了fiber之后，fiber作为虚拟DOM去更新时，更新的过程叫做"),r("span",{staticStyle:{color:"red"}},[r("code",[t._v("Reconciler")])]),t._v("（调和器），每一个fiber都可以作为一个执行单元来处理，每个fiber可以根据自身的过期时间 "),r("span",{staticStyle:{color:"red"}},[r("code",[t._v("expirationTime")])]),t._v(" 来判断是否还有时间执行更新，如果没有时间更新，则浏览器可以进行渲染操作，做一些动画、重排、重绘之类的事情，等到浏览器空闲时间的时候就可以通过"),r("span",{staticStyle:{color:"red"}},[r("code",[t._v("Scheduler")])]),t._v("（调度器），则继续上次更新中断的fiber（执行单元）处，这样就本质身上中断了渲染，提高了用户的使用体验。")]),t._v(" "),r("h4",{attrs:{id:"_2-reactelement、fiber、dom-三者之间的关系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-reactelement、fiber、dom-三者之间的关系"}},[t._v("#")]),t._v(" 2. ReactElement、fiber、DOM 三者之间的关系")]),t._v(" "),r("p",[t._v("​\t"),r("code",[t._v("ReactElement")]),t._v("元素是由我们所写的"),r("code",[t._v("JSX")]),t._v("代码通过"),r("span",{staticStyle:{color:"red"}},[r("code",[t._v("babel")])]),t._v("编译后(@babel/plugin-syntax-jsx和@babel/plugin-transform-react-jsx这两个插件)，会调用"),r("code",[t._v("React.createElement方法")]),t._v(" 最终按照一定的规则转换成"),r("code",[t._v("ReactElement")]),t._v("对象。")]),t._v(" "),r("p",[t._v("​\t举个例子：")]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714135904108.png",alt:"image-20220714135904108"}}),t._v(" "),r("p",[t._v("​\t这是我们日常开发中的JSX代码，它会被babel编译成：")]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714135919910.png",alt:"image-20220714135919910"}}),t._v(" "),r("p",[t._v("​\t我们点击按钮，查看最后生成的"),r("code",[t._v("ReactElement")]),t._v("对象：")]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714135931951.png",alt:"image-20220714135931951"}}),t._v(" "),r("p",[t._v("​\t在调和阶段中"),r("code",[t._v("ReactElement")]),t._v("对象会转换成"),r("code",[t._v("fiber")]),t._v("对象，根据对应的类型和数据生成DOM元素。")]),t._v(" "),r("p",[r("img",{attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714135941949.png",alt:"image-20220714135941949"}})]),t._v(" "),r("h4",{attrs:{id:"_3-不同的fiber之间如何建立联系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-不同的fiber之间如何建立联系"}},[t._v("#")]),t._v(" 3. 不同的fiber之间如何建立联系")]),t._v(" "),r("p",[t._v("​\t首先我们看下fiber的数据结构是怎样的：")]),t._v(" "),r("blockquote",[r("p",[t._v("对应react源码位置    react-reconciler/src/ReactFiber.js")])]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714135951319.png",alt:"image-20220714135951319"}}),t._v(" "),r("p",[t._v("​\t数据非常多，目前我们重点关注"),r("code",[t._v("return")]),t._v("、"),r("code",[t._v("child")]),t._v("、"),r("code",[t._v("sibling")]),t._v("这三个属性。")]),t._v(" "),r("p",[t._v("​\t每一个"),r("code",[t._v("ReactElement")]),t._v("都会对应一个"),r("code",[t._v("fiber")]),t._v("，每一个"),r("code",[t._v("fiber")]),t._v("都是通过"),r("code",[t._v("return")]),t._v("、"),r("code",[t._v("child")]),t._v("、"),r("code",[t._v("sibling")]),t._v("连接起来的")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("return： 指向父级 Fiber 节点。")])]),t._v(" "),r("li",[r("p",[t._v("child： 指向子 Fiber 节点。")])]),t._v(" "),r("li",[r("p",[t._v("sibling：指向兄弟 fiber 节点。")]),t._v(" "),r("p",[t._v("比如项目的代码结构是这样的：")]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714140008673.png",alt:"image-20220714140008673"}}),t._v(" "),r("p",[t._v("fiber的对应关系如图：")]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714140020647.png",alt:"image-20220714140020647"}})])]),t._v(" "),r("h4",{attrs:{id:"_4-双缓冲树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-双缓冲树"}},[t._v("#")]),t._v(" 4. 双缓冲树")]),t._v(" "),r("p",[t._v("​\t为什么我们需要双缓冲？双缓冲本质上解决了什么问题呢？")]),t._v(" "),r("p",[t._v("​\t我们在对图形进行编程绘制的时候，需要多个复杂画图操作的图形操作会导致呈现的图像出现闪烁或不可接受的外观。")]),t._v(" "),r("p",[t._v("​\t双缓冲使用内容缓冲来解决与多个画图相关的闪烁问题，启用双缓冲后，所有画图操作首先呈现到内存缓冲而不是屏幕上的绘图，所有画图操作在内存中完成之后，直接复制到与之关联的绘图图面。这样屏幕上仅有一个图形操作，因为与复杂图画相关的图像闪烁也就得以消除。")]),t._v(" "),r("p",[t._v("​\t这一点也是应用在了"),r("code",[t._v("canvas")]),t._v("中，新建一个canvas来作为缓存的canvas，通过缓存的"),r("code",[t._v("canvas")]),t._v("完成绘制过程，绘制完成后，直接将缓存的"),r("code",[t._v("canvas")]),t._v("替换掉原来的"),r("code",[t._v("canvas")]),t._v("，这样就解决了canvas绘制时间过长导致的闪屏问题。")]),t._v(" "),r("p",[t._v("​\tReact中用"),r("code",[t._v("workInProgress")]),t._v("树(内存中构建的树)和"),r("code",[t._v("current")]),t._v("树(渲染树)来实现更新逻辑。双缓存一个在内存中构建，一个渲染视图，两颗树用 alternate 指针相互指向，在下一次渲染的时候，直接复用缓存树做为下一次渲染树，上一次的渲染树又作为缓存树，这样可以防止只用一颗树更新状态的丢失的情况，又加快了 DOM 节点的替换与更新。")]),t._v(" "),r("p",[t._v("​\t下面用挂载和更新举例：")]),t._v(" "),r("p",[t._v("​\t"),r("strong",[t._v("第一步：创建fiberRoot和RootFiber")])]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714140036216.png",alt:"image-20220714140036216"}}),t._v(" "),r("p",[t._v("​\t简单介绍一下"),r("code",[t._v("fiberRoot")]),t._v("和"),r("code",[t._v("RootFiber")])]),t._v(" "),r("ul",[r("li",[r("p",[r("code",[t._v("fiberRoot")]),t._v("：首次构建应用， 创建一个 fiberRoot ，作为整个 React 应用的根基。")])]),t._v(" "),r("li",[r("p",[r("code",[t._v("rootFiber")]),t._v("： 通过 ReactDOM.render 渲染出来的，如举例中的 Index 可以作为一个rootFiber。")])])]),t._v(" "),r("p",[t._v("​\t一个 React 应用可以有多 ReactDOM.render 创建的 rootFiber ，但是只能有一个 fiberRoot（应用根节点）。")]),t._v(" "),r("p",[t._v("​\t"),r("strong",[t._v("第二步：workInProgress和current")])]),t._v(" "),r("ul",[r("li",[r("p",[t._v("workInProgress是：正在内存中构建的 Fiber 树称为 workInProgress Fiber 树。在一次更新中，所有的更新都是发生在 workInProgress 树上。在一次更新之后，workInProgress 树上的状态是最新的状态，那么它将变成 current 树用于渲染视图。")])]),t._v(" "),r("li",[r("p",[t._v("current：正在视图层渲染的树叫做 current 树。")]),t._v(" "),r("p",[t._v("接下来会到 rootFiber 的渲染流程，首先会复用当前 current 树（ rootFiber ）的 "),r("code",[t._v("alternate")]),t._v(" 作为 workInProgress ，如果没有 alternate （初始化的 rootFiber 是没有 alternate ），那么会创建一个 fiber 作为 workInProgress 。会用 alternate 将新创建的 workInProgress 与 current 树建立起关联。这个关联过程只有初始化第一次创建 alternate 时候进行。")]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714140051830.png",alt:"image-20220714140051830"}}),t._v(" "),r("p",[r("strong",[t._v("第三步：深度调和子节点，渲染视图")])]),t._v(" "),r("p",[t._v("在current树新建的alternate指针上，完成整个 fiber 树的遍历，包括 fiber 的创建。")]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714140104003.png",alt:"image-20220714140104003"}})])]),t._v(" "),r("p",[t._v("​\t最后会以 workInProgress 作为最新的渲染树，fiberRoot 的 current 指针指向 workInProgress 使其变为 current Fiber 树。到此完成初始化流程。")]),t._v(" "),r("p",[t._v("​\t"),r("strong",[t._v("更新")])]),t._v(" "),r("p",[t._v("​\t点击一次按钮发生更新，接下来会发生什么呢? 首先会走如上的逻辑，重新创建一颗 workInProgresss 树，复用当前 current 树上的 alternate ，作为新的 workInProgress ，由于初始化 rootfiber 有 alternate ，所以对于剩余的子节点，React 还需要创建一份，和 current 树上的 fiber 建立起 alternate 关联。渲染完毕后，workInProgresss 再次变成 current 树")]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714140119019.png",alt:"image-20220714140119019"}}),t._v(" "),r("h4",{attrs:{id:"_5-react中两大核心模块-调度与调和"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-react中两大核心模块-调度与调和"}},[t._v("#")]),t._v(" 5. react中两大核心模块: 调度与调和")]),t._v(" "),r("p",[t._v("​\t"),r("strong",[t._v("调度模块")])]),t._v(" "),r("p",[t._v("​\tReact做不到像Vue那样通过template模板去收集依赖，构建响应式。Vue中一次更新，能够迅速相应，找到需要更新的范围，以组件为粒度去更新组件从而渲染视图。React目前为止还无法打破从根Root开始遍历更新diff，那么就只能从解决浏览器卡顿方面入手了。调度(Scheduler)就是React具体实现解决更新造成浏览器卡顿的方式。")]),t._v(" "),r("p",[t._v("​\tReact 如何让浏览器控制 React 更新呢，首先浏览器每次执行一次事件循环（一帧）都会做如下事情：处理事件，执行 js ，调用 requestAnimation ，布局 Layout ，绘制 Paint ，在一帧执行后，如果没有其他事件，那么浏览器会进入休息时间，那么有的一些不是特别紧急 React 更新，就可以执行了。")]),t._v(" "),r("p",[t._v("​\t如何去判断浏览器是否有空闲时间呢？")]),t._v(" "),r("p",[r("code",[t._v("requestIdleCallback")])]),t._v(" "),r("blockquote",[r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("  在浏览器有空余的时间，浏览器就会调用 requestIdleCallback 的回调。首先看一下 requestIdleCallback的基本用法\n  requestIdleCallback(callback,{ timeout })\n")])])])]),t._v(" "),r("ul",[r("li",[r("p",[t._v("callback 回调，浏览器空余时间执行回调函数。")])]),t._v(" "),r("li",[r("p",[t._v("timeout 超时时间。如果浏览器长时间没有空闲，那么回调就不会执行，为了解决这个问题，可以通过 requestIdleCallback 的第二个参数指定一个超时时间。")]),t._v(" "),r("p",[t._v("React 为了防止 requestIdleCallback 中的任务由于浏览器没有空闲时间而卡死，所以设置了 5 个优先级。")])]),t._v(" "),r("li",[r("p",[r("code",[t._v("Immediate")]),t._v(" -1 需要立刻执行。")])]),t._v(" "),r("li",[r("p",[r("code",[t._v("UserBlocking")]),t._v(" 250ms 超时时间250ms，一般指的是用户交互。")])]),t._v(" "),r("li",[r("p",[r("code",[t._v("Normal")]),t._v(" 5000ms 超时时间5s，不需要直观立即变化的任务，比如网络请求。")])]),t._v(" "),r("li",[r("p",[r("code",[t._v("Low")]),t._v(" 10000ms 超时时间10s，肯定要执行的任务，但是可以放在最后处理。")])]),t._v(" "),r("li",[r("p",[r("code",[t._v("Idle")]),t._v(" 一些没有必要的任务，可能不会执行。")]),t._v(" "),r("p",[t._v("React 的异步调度任务就是通过 requestIdleCallback或MessageChannel(requestIdleCallback存在兼容性问题) 去向浏览器做一帧一帧请求，等到浏览器有空余时间，去执行 React 的异步更新任务，这样保证页面的流畅")]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714140134915.png",alt:"image-20220714140134915"}})])]),t._v(" "),r("p",[t._v("​\t接下来看看调度任务的实现。")]),t._v(" "),r("p",[t._v("​\tReact发生一次更新，会统一的走ensureRootIsScheduled(调度应用)")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("对于正常更新会走 performSyncWorkOnRoot 逻辑，最后会走 "),r("code",[t._v("workLoopSync")]),t._v(" 。")])]),t._v(" "),r("li",[r("p",[t._v("对于低优先级的异步更新会走 performConcurrentWorkOnRoot 逻辑，最后会走 "),r("code",[t._v("workLoopConcurrent")]),t._v(" 。")]),t._v(" "),r("blockquote",[r("p",[t._v("对应源码位置 react-reconciler/src/ReactFiberWorkLoop.js")])])])]),t._v(" "),r("div",{staticClass:"language-javascript extra-class"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("workLoopSync")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    workInProgress "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("performUnitOfWork")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),r("div",{staticClass:"language-javascript extra-class"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("workLoopConcurrent")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldYield")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    workInProgress "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("performUnitOfWork")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),r("p",[t._v("​\t在一次更新调度过程中，workLoop 会更新执行每一个待更新的 fiber 。他们的区别就是异步模式会调用一个 shouldYield() ，如果当前浏览器没有空余时间， shouldYield 会中止循环，直到浏览器有空闲时间后再继续遍历，从而达到终止渲染的目的。这样就解决了一次性遍历大量的 fiber ，导致浏览器没有时间执行一些渲染任务，导致了页面卡顿。")]),t._v(" "),r("p",[t._v("​\t调度的内容非常的多，步骤也是非常的复杂，例如任务队列"),r("code",[t._v("taskQueue")]),t._v("和"),r("code",[t._v("timerQueue")]),t._v(",对超时任务的处理，延时任务的处理等等。这些都是调度模块的核心，不再叙述，下面贴一张调度的流程图：")]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714140147632.png",alt:"image-20220714140147632"}}),t._v(" "),r("p",[r("strong",[t._v("调和模块")])]),t._v(" "),r("p",[t._v("​\t"),r("strong",[t._v("render阶段")])]),t._v(" "),r("p",[t._v("​\t通过调度的任务进入workLoop之后，如果渲染没有被中断的情况下，那么workLoop会遍历fiber树，进入上述代码块中的"),r("code",[t._v("performUnitOfWork")]),t._v("方法")]),t._v(" "),r("blockquote",[r("p",[t._v("对应源码位置  react-reconciler/src/ReactFiberWorkLoop.js")])]),t._v(" "),r("div",{staticClass:"language-javascript extra-class"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("performUnitOfWork")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    next "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("beginWork")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("current"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" unitOfWork"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" renderExpirationTime"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("next "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n       next "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("completeUnitOfWork")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("unitOfWork"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),r("p",[t._v("​\t"),r("code",[t._v("beginWork")]),t._v("：是向下调和的过程。就是由 fiberRoot 按照 child 指针逐层向下调和，期间会执行函数组件，实例类组件，diff 调和子节点，打不同effectTag。")]),t._v(" "),r("p",[t._v("​\t"),r("code",[t._v("completeUnitOfWork")]),t._v("：是向上归并的过程，如果有兄弟节点，会返回 sibling兄弟，没有返回 return 父级，一直返回到 fiebrRoot ，期间可以形成effectList，对于初始化流程会创建 DOM ，对于 DOM 元素进行事件收集，处理style，className等。")]),t._v(" "),r("p",[r("strong",[t._v("调和顺序")])]),t._v(" "),r("p",[t._v("​\t以Index组件的代码为例，初始化或者更新中的调和顺序如下：")]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714140204868.png",alt:"image-20220714140204868"}}),t._v(" "),r("ul",[r("li",[r("p",[t._v("beginWork -> rootFiber")])]),t._v(" "),r("li",[r("p",[t._v("beginWork -> Index fiber")])]),t._v(" "),r("li",[r("p",[t._v("beginWork -> div fiber")])]),t._v(" "),r("li",[r("p",[t._v("beginWork -> hello,world fiber")])]),t._v(" "),r("li",[r("p",[t._v("completeWork -> hello,world fiber (completeWork返回sibling)")])]),t._v(" "),r("li",[r("p",[t._v("beginWork -> p fiber")])]),t._v(" "),r("li",[r("p",[t._v("completeWork -> p fiber")])]),t._v(" "),r("li",[r("p",[t._v("beginWork -> button fiber")])]),t._v(" "),r("li",[r("p",[t._v("completeWork -> button fiber (此时没有sibling，返回return)")])]),t._v(" "),r("li",[r("p",[t._v("completeWork -> div fiber")])]),t._v(" "),r("li",[r("p",[t._v("completeWork -> Index fiber")])]),t._v(" "),r("li",[r("p",[t._v("completeWork -> rootFiber (完成整个workLoop)")]),t._v(" "),r("blockquote",[r("p",[t._v("没有 《React进阶实践指南》 和 点赞 的 文本fiber的beginWork/completeWork流程，是因为作为一种性能优化手段，针对只有单一文本子节点的Fiber，React会特殊处理。")])])])]),t._v(" "),r("p",[r("strong",[t._v("commit阶段")])]),t._v(" "),r("p",[t._v("​\t既然完成 render 阶段，接下来将进行第二阶段 commit 阶段。commit 阶段做的事情是：")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("一方面是对一些生命周期和副作用钩子的处理，比如 componentDidMount ，函数组件的 useEffect ，useLayoutEffect ；")])]),t._v(" "),r("li",[r("p",[t._v("另一方面就是在一次更新中，添加节点（ "),r("code",[t._v("Placement")]),t._v(" ），更新节点（ "),r("code",[t._v("Update")]),t._v(" ），删除节点（ "),r("code",[t._v("Deletion")]),t._v(" ），还有就是一些细节的处理。")])])]),t._v(" "),r("p",[r("strong",[t._v("commit")]),t._v(" 细分可以分为：")]),t._v(" "),r("ul",[r("li",[r("code",[t._v("Before mutation")]),t._v(" 阶段（执行 DOM 操作前）；")]),t._v(" "),r("li",[r("code",[t._v("mutation")]),t._v(" 阶段（执行 DOM 操作）；")]),t._v(" "),r("li",[r("code",[t._v("layout")]),t._v(" 阶段（执行 DOM 操作后）")])]),t._v(" "),r("p",[r("strong",[t._v("Before mutation")]),t._v(" 阶段做的事主要有以下内容：")]),t._v(" "),r("ul",[r("li",[t._v("因为 Before mutation 还没修改真实的 DOM ，是获取 DOM 快照的最佳时期，如果是类组件有 getSnapshotBeforeUpdate ，那么会执行这个生命周期。")]),t._v(" "),r("li",[t._v("会异步调用 useEffect ，在生命周期章节讲到 useEffect 是采用异步调用的模式，其目的就是防止同步执行时阻塞浏览器做视图渲染。")])]),t._v(" "),r("p",[r("strong",[t._v("mutation")]),t._v(" 阶段做的事情有：")]),t._v(" "),r("ul",[r("li",[t._v("对新增元素，更新元素，删除元素。进行真实的 DOM 操作。")])]),t._v(" "),r("p",[r("strong",[t._v("Layout")]),t._v(" 阶段 DOM 已经更新完毕，Layout 做的事情有：")]),t._v(" "),r("ul",[r("li",[t._v("commitLayoutEffectOnFiber 对于类组件，会执行生命周期，setState 的callback，对于函数组件会执行 useLayoutEffect 钩子。")])]),t._v(" "),r("p",[t._v("接下来对 commit 阶段做一个总结，主要做的事就是执行effectList，更新DOM，执行生命周期，获取ref等操作。")]),t._v(" "),r("p",[r("strong",[t._v("调度+调和顺序流程图")])]),t._v(" "),r("img",{staticStyle:{zoom:"33%"},attrs:{src:"http://rezpusy5t.hn-bkt.clouddn.com/image-20220714140216338.png",alt:"image-20220714140216338"}})])}),[],!1,null,null,null);e.default=s.exports}}]);